// В JavaScript существует четыре основных способа появления идентификатора в области видимости:
// 1) Внутренние механизмы языка: например, во всех областях видимости доступны this и arguments.
// 2) Формальные параметры: у функций могут быть именованные формальные параметры,
// область видимости которых ограничена телом функции.
// 3) Объявления функций: объявленные в виде function foo() {}.
// 4) Объявления переменных: например, var foo;.

// JavaScript непреклонно сначала объявляет, а уже затем инициализирует наши переменные.


// Но однако, необъявленные переменные не существуют до тех пор,
// пока код назначающий их не будет выполнен.
// Следовательно, указание значения для необъявленной переменной,
// тут же создаёт её как глобальную переменную, когда назначение будет выполнено.
// Это говорит о том, что все необъявленные переменные это по факту - Глобальные переменные.
// Чтобы продемонстрировать это поведение, давайте посмотрим на следующий код.
// function hoist() {
//   a = 20;
//   var b = 100;
// }
//
// hoist();
// console.log(a); // 20

// Как только b была назначена, она заключена в рамки области видимости функции hoist().
// Что означает то, что мы не можем вывести её за рамки функции.
// console.log(b); // ReferenceError: b is not defined

// ===================================================

// console.log(hoist); // Вывод: undefined
//
// var hoist = 'The variable has been hoisted.';

// JavaScript «поднял» объявление переменной. Вот как это выглядит для движка JavaScript:

// var hoist;
//
// console.log(hoist); // Вывод: undefined
// hoist = 'The variable has been hoisted.';

// JavaScript «поднимает» переменные let и const.
// Разница лишь в том, как он инициализирует их.
// Переменные объявленные с let и const остаются неинициализированными
// в начале выполнения, в то время как переменные объявленные с var инициализируются со значением undefined.
//
// expression();
//
// var expression = function() {
//   console.log('Will this work?');
// };

// Порядок по приоритетам:
// 1) Назначение переменных имеет приоритет перед объявлением функции.

// var double = 22;
//
// function double(num) {
//   return (num*2);
// }
//
// console.log(typeof double); // Вывод: number

// 2) Объявление функции имеет приоритет перед объявлением переменной.
//Объявления функций «поднимаются» над объявлением переменных, но не над их назначениями.

// var double;
//
// function double(num) {
//   return (num*2);
// }
//
// console.log(typeof double); // Вывод: function

// Так же как и свои коллеги функции, JavaScript классы при объявлении «поднимаются».
// Тем не менее, они остаются неинициализированными до определения.
// Это говорит о том, что вам надо объявить класс перед тем, как его использовать.

// var Frodo = new Hobbit();
// Frodo.height = 100;
// Frodo.weight = 300;
// console.log(Frodo); // Вывод: ReferenceError: Hobbit is not defined
//
// class Hobbit {
//   constructor(height, weight) {
//     this.height = height;
//     this.weight = weight;
//   }
// }

// Разница между объявлениями var / function и объявлениями let / const / class заключается в инициализации.
// Первые инициализируются с неопределенным значением undefined.
// Однако, вторые, лексически объявленные переменные, остаются не инициализированными.
// Это означает, что ReferenceError выбрасывается при попытке доступа к ним.
// Они будут инициализированы только после того, как операторы let / const / class будут определены.
// Всё что до, называется временной мертвой зоной.

// Временная мертвая зона - это не синтаксическое местоположение, а время
// между созданием переменной (области) и инициализацией.
// Ссылка на переменную в коде над объявлением не является ошибкой,
// если этот код не выполняется (например, тело функции или просто мертвый код),
// но ошибка будет выдана, если мы запросим доступ к переменной до её инициализации.
